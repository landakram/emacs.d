#+TITLE: Mark's Emacs Config
#+OPTIONS: toc:2 num:nil ^:nil

* Introduction
Welcome to my emacs config!
* Prelude
First, let's take care of some startup stuff.
** Remove the startup message

I don't like the startup message, so let's get rid of it.

#+BEGIN_SRC emacs-lisp

(setq inhibit-startup-message t)

#+END_SRC

** Set the Custom file

Let's set ~custom-file~, which emacs writes to automatically.

#+BEGIN_SRC emacs-lisp

(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file)

#+END_SRC
* Packages
** Set up ~package.el~

#+BEGIN_SRC emacs-lisp

(require 'package)
(setq package-archives
      '(("gnu" . "http://elpa.gnu.org/packages/")
        ("org" . "http://orgmode.org/elpa/")
        ("melpa" . "http://melpa.org/packages/")
        ("marmalade" . "http://marmalade-repo.org/packages/")))

(package-initialize)

#+END_SRC
** Install ~use-package~

~use-package~ is used for the rest of the config. It lets me define installable packages and configure them in the same block.

#+BEGIN_SRC emacs-lisp

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))

#+END_SRC

#+RESULTS:
: diminish
** Install ~diminish~

We also install ~diminish~, because ~use-package~ depends on it. ~diminish~ lets you hide minor modes from the mode-line.

#+BEGIN_SRC emacs-lisp

(unless (package-installed-p 'diminish)
  (package-install 'diminish))

(require 'diminish)

#+END_SRC

Now, we explicitly load some modes that are en
Now, we diminish some modes (I can't figure out where they are loaded):

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode)
  (diminish 'auto-revert-mode)
#+END_SRC

#+RESULTS:
|   |
** Try packages without installing

#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC

#+RESULTS:
** Better interface for packages

Brought to you by Paradox:

#+BEGIN_SRC emacs-lisp
  (use-package paradox
    :ensure t)
#+END_SRC

#+RESULTS:

* General Configuration
Let's configure the editor to our liking.
** Symlinks

Follow symlinks without prompting me.

#+BEGIN_SRC emacs-lisp

  (setq vc-follow-symlinks t)

#+END_SRC
** Ignore files
Life's too short to see this many files in dired / projectile / etc.

#+BEGIN_SRC emacs-lisp

  (use-package ignoramus
    :ensure t
    :config
    (ignoramus-setup))

#+END_SRC

#+RESULTS:
: t
** Use org for the scratch buffer

#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode 'org-mode)
  (setq initial-scratch-message "\
  # This buffer is for notes you don't want to save.")
#+END_SRC

#+RESULTS:
: # This buffer is for notes you don't want to save.

** Change "yes or no" to "y or n"

#+BEGIN_SRC emacs-lisp 

(defalias 'yes-or-no-p 'y-or-n-p)

#+END_SRC

** Enable flycheck

Flycheck is an on-the-fly syntax checker.

#+BEGIN_SRC emacs-lisp 

  (use-package flycheck
    :ensure t
    :diminish flycheck-mode
    :config
    (global-flycheck-mode))

#+END_SRC

#+RESULTS:
: t

** Disable bell ring

#+BEGIN_SRC emacs-lisp 

(setq ring-bell-function 'ignore)

#+END_SRC

** Better defaults

#+BEGIN_SRC emacs-lisp 

  (use-package better-defaults
    :ensure t)

#+END_SRC

#+RESULTS:
|   |

** Better search

I use ~ag~ religiously on the command line. Let's use it in emacs too.

#+BEGIN_SRC emacs-lisp 

(use-package ag
  :ensure t)

#+END_SRC

** Visual fill column

Visually wraps lines according to the value of ~fill-column~. Unlike ~fill-column~, ~visual-fill-column~ does not *actually* wrap text in the file. It just displays it as wrapped.

#+BEGIN_SRC emacs-lisp 

  (use-package visual-fill-column
    :ensure t
    :diminish visual-line-mode
    :config
    (add-hook 'text-mode-hook 'visual-fill-column-mode)
    (global-visual-line-mode))

#+END_SRC

#+RESULTS:
: t

** which-key

Remembering keyboard shortcuts is hard. which-key pops up a buffer reminding me of shortcuts when I start typing them.

#+BEGIN_SRC emacs-lisp 

(use-package which-key
  :ensure t
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 0.5)
  (which-key-mode))

#+END_SRC

#+RESULTS:
: t

** Fix the PATH variable

This sets up emacs to inherit commands from ~$PATH~. Without it, some commands that are available in the shell would not be available in emacs.

#+BEGIN_SRC emacs-lisp 

  (use-package exec-path-from-shell
    :ensure t
    :config
    (exec-path-from-shell-initialize))

  ;; (defun set-exec-path-from-shell-PATH ()
  ;;   (let ((path-from-shell (shell-command-to-string "env TERM=vt100 /bin/zsh -i -c 'echo $PATH'")))
  ;;     (setenv "PATH" path-from-shell)
  ;;     (setq exec-path (split-string path-from-shell path-separator))))

  ;; (when window-system (set-exec-path-from-shell-PATH))

#+END_SRC

#+RESULTS:
: t

** Make gpg-agent work
This function will load ~/.gpg-agent-info and source its contents into ~GPG_AGENT_INFO~.

I need this to pull mail for m4ue.

#+BEGIN_SRC emacs-lisp
  (defun my/gpg-agent ()
    "Load your gpg-agent.env file in to the environment

  This is extra useful if you use gpg-agent with --enable-ssh-support"
    (interactive)
    (let ((home (getenv "HOME"))
          (old-buffer (current-buffer)))
      (with-temp-buffer
        (insert-file-contents (concat home "/.gpg-agent-info"))
        (goto-char (point-min))
        (setq case-replace nil)
        (replace-regexp "\\(.*\\)=\\(.*\\)" "(setenv \"\\1\" \"\\2\")")
        (eval-buffer)))
    (message (getenv "GPG_AGENT_INFO")))

  (run-with-idle-timer 60 t 'my/gpg-agent)
  (my/gpg-agent)
#+END_SRC

#+RESULTS:
: /tmp/gpg-slIax0/S.gpg-agent:787:1

** Theme
*** Change the Mode Line
This mode line is pretty.

#+BEGIN_SRC emacs-lisp 

  (use-package smart-mode-line
    :ensure t
    :config
    (setq sml/theme 'respectful)
    (sml/setup))

#+END_SRC

#+RESULTS:
: t

#+RESULTS:

*** Change the theme

The "Monokai" themes look great in emacs and a terminal.

#+BEGIN_SRC emacs-lisp 

  (use-package monokai-theme
    :ensure t
    :config
    (setq monokai-use-variable-pitch nil)
    (load-theme 'monokai t))


  ;; (use-package color-theme-sanityinc-tomorrow
  ;;   :ensure t
  ;;   :config
  ;;   (color-theme-sanityinc-tomorrow-eighties))

#+END_SRC

#+RESULTS:
: t

*** Per-buffer themes

I'd like to use a light theme for email and org mode.

It's commented out right now because it looks terrible.

#+BEGIN_SRC emacs-lisp
  ;; (use-package color-theme
  ;;   :ensure t)


  ;; (use-package load-theme-buffer-local
  ;;   :ensure t
  ;;   :config
  ;;   (add-hook 'org-mode-hook (lambda ()
  ;;                              (load-theme-buffer-local
  ;;                               'leuven
  ;;                               (current-buffer)))))

  ;; (use-package color-theme-buffer-local
  ;;   :ensure t)
#+END_SRC

#+RESULTS:

* Helm
** TODO organize this

#+BEGIN_SRC emacs-lisp 

  ;;;; Helm

  (use-package helm
    :ensure t
    :diminish helm-mode
    :config

    (require 'helm-config)
    (require 'helm-locate)

    ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
    ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
    ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
    (global-set-key (kbd "C-c h") 'helm-command-prefix)
    (global-unset-key (kbd "C-x c"))

    ;; Use helm for finding files
    (global-set-key (kbd "C-x C-f") 'helm-find-files)

    (setq helm-split-window-in-side-p           t ; open helm buffer inside current window
          helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
          helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
          helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
          helm-ff-file-name-history-use-recentf t)

    ;; Use helm for M-x
    (global-set-key (kbd "M-x") 'helm-M-x)

    ;; Use helm to show the kill ring
    (global-set-key (kbd "M-y") 'helm-show-kill-ring)

    ;; Use helm for buffer list
    (global-set-key (kbd "C-x b") 'helm-mini)

    ;; Use helm for apropos
    (global-set-key (kbd "C-h a") 'helm-apropos)
    
    ;; Don't cut off filenames
    (setq helm-buffer-max-length nil)

    (helm-mode 1))

  (use-package helm-ag
    :ensure t)

  (use-package helm-projectile
    :ensure t
    :config
    (helm-projectile-on))

  (use-package helm-mu
    :ensure t)

#+END_SRC
#+RESULTS:

* Keybindings
** General keybindings
*** Increase and decrease text size

#+BEGIN_SRC emacs-lisp 

(define-key global-map (kbd "C-=") 'text-scale-increase)
(define-key global-map (kbd "C--") 'text-scale-decrease)

#+END_SRC

** Evil Mode
*** TODO organize this

#+BEGIN_SRC emacs-lisp 

  (defun split-window-right-and-focus ()
    (interactive)
    (split-window-right)
    (other-window 1))

  (defun split-window-below-and-focus ()
    (interactive)
    (split-window-below)
    (other-window 1))

  (use-package evil
    :ensure t
    :diminish evil-mode
    :diminish undo-tree-mode
    :init
    (setq evil-want-C-u-scroll t)
    :config
    ;; Make movement keys work over visual lines
    (define-key evil-normal-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
    (define-key evil-normal-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
    (define-key evil-motion-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
    (define-key evil-motion-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
    ;; Make horizontal movement cross lines               
    (setq-default evil-cross-lines t)

    (define-key evil-normal-state-map "f" 'avy-goto-word-or-subword-1)

    (evil-mode 1)

    (use-package evil-surround
      :ensure t
      :diminish evil-surround-mode
      :config
      (global-evil-surround-mode 1))

    (use-package evil-magit
      :ensure t)

    (use-package evil-matchit
      :ensure t
      :config
      (global-evil-matchit-mode 1))

    (use-package evil-leader
      :ensure t
      :config

      (evil-leader/set-leader "SPC")

      (evil-leader/set-key "x" 'helm-M-x)
      (evil-leader/set-key "f" 'helm-find-files)

      ;; Buffer
      (evil-leader/set-key "b" 'helm-mini)
      (evil-leader/set-key "k" 'kill-this-buffer)
      (evil-leader/set-key "w" 'save-buffer)
      (evil-leader/set-key "q" 'delete-window)
  
      (evil-leader/set-key "|" 'split-window-right-and-focus)
      (evil-leader/set-key "-" 'split-window-below-and-focus)

      ;; Projects
      (evil-leader/set-key "pp" 'helm-projectile-switch-project)
      (evil-leader/set-key "pf" 'helm-projectile-find-file)
      (evil-leader/set-key "pa" 'helm-projectile-ag)

      ;; Config edit
      (evil-leader/set-key "ce" (lambda () (interactive) (find-file "~/.emacs.d/config.org")))

      ;; Git
      (evil-leader/set-key "g" 'magit-status)
  
      ;; Ace window
      ;; This keybinding matches "f" in normal mode for avy, in terms 
      ;; of hand placement.
      (evil-leader/set-key "j" 'ace-window)
      (global-set-key (kbd "M-j") 'ace-window)

      (setq evil-leader/in-all-states 1)
      (global-evil-leader-mode)))

#+END_SRC

#+RESULTS:
: t

* Navigating
** Projectile
Projectile lets me switch between projects really easily. I set it up to default to ~projectile-commander~, which gives me options to choose what I want to do with a project once I open it.

#+BEGIN_SRC emacs-lisp 

  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :config
    (setq projectile-enable-caching t)
    (projectile-global-mode)
    (setq projectile-completion-system 'helm)
    (setq projectile-switch-project-action 'projectile-commander)

    ;; Clear out all commander commands but the help item.
    (setq projectile-commander-methods (list (car projectile-commander-methods)))
    ;; (delete-if (lambda (el)
    ;;              (member (car el) '(?d ?a ?g)))
    ;;            projectile-commander-methods)

    (def-projectile-commander-method ?d
      "Open project root in dired"
      (projectile-dired)))

    (def-projectile-commander-method ?a
      "Full text search in the project."
      (helm-projectile-ag))

    (def-projectile-commander-method ?e
      "Open an [e]shell in the project root."
      (projectile-run-eshell))

    (def-projectile-commander-method ?f
      "Find files in the project."
      (helm-projectile-find-file))

    (def-projectile-commander-method ?g
      "Open project root in magit"
      (projectile-vc))

#+END_SRC

#+RESULTS:
| 63 | Commander help buffer. | #[0 \302\303\304D\305\303\306\302EDC\217\210r\307!q\210\310c\210        \311\203@ @\211\211A\262\242\211A\262\242@\312\313#c\266\211T\262A\262\202 \266eb\210\314 \210\315p\316"\210)\317 \207 [projectile-commander-help-buffer projectile-commander-methods err funcall #[0 \301!\207 [projectile-commander-help-buffer kill-buffer] 2 |

** Avy
Avy lets me jump around buffers and windows with hints.

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :config
    ;; Favor home-row and surrounding keys
    (setq avy-keys
          '(?h ?j ?k ?l ?a ?s ?d ?f ?g ?y ?u ?i ?o ?p ?q ?w ?e ?r ?t ?n ?m ?z ?x ?c ?v ?b)))
#+END_SRC

#+RESULTS:
: t
** Ace-Window
Ace window is like avy but for windows.

#+BEGIN_SRC emacs-lisp
    (use-package ace-window
      :ensure t
      :config
      (setq aw-keys '(?h ?j ?k ?l ?a ?s ?d ?f ?g ?y ?u ?i ?o ?p ?q ?w ?e ?r ?t ?n ?m ?z ?x ?c ?v ?b)))
#+END_SRC

#+RESULTS:
: t
* Coding
** Testing

Install Jorgen Schaefer's ~tdd~ library, which lets me auto-run tests when a buffer is saved.

#+BEGIN_SRC emacs-lisp
  (use-package tdd
    :load-path "site-lisp/tdd/")
#+END_SRC

#+RESULTS:

** Autocomplete

#+BEGIN_SRC emacs-lisp 

  (use-package company
    :ensure t
    :config
    (global-company-mode)) 
#+END_SRC

#+RESULTS:
: t

** Git
*** Magit
#+BEGIN_SRC emacs-lisp 

(use-package magit
  :ensure t)

#+END_SRC
*** GitHub integration
**** Open GitHub from Helm
#+BEGIN_SRC emacs-lisp 

(use-package helm-open-github
  :ensure t)

#+END_SRC

** Snippets

#+BEGIN_SRC emacs-lisp 

;; Yasnippet

(use-package yasnippet
  :ensure t
  :config

  ;; Make Yasnippet work in Org
  (defun yas/org-very-safe-expand ()
    (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))

  (add-hook 'org-mode-hook
            (lambda ()
              (make-variable-buffer-local 'yas/trigger-key)
              (setq yas/trigger-key [tab])
              (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
              (define-key yas/keymap [tab] 'yas/next-field)))

  (yas-global-mode 1))


#+END_SRC

** Lisp
*** TODO organize

#+BEGIN_SRC emacs-lisp 

  (defun start-figwheel ()
    "Start figwheel. This function is meant to be called interactively after `cider-jack-in`."
    (interactive)
    (cider-interactive-eval
     "(use 'figwheel-sidecar.repl-api) \n
      (start-figwheel!) \n
      (cljs-repl) \n"))

  (use-package evil-cleverparens
    :ensure t)

  (use-package cider
    :ensure t
    :config
    ;; Start figwheel when I run `M-x cider-jack-in-clojurescript`
    (setq cider-cljs-lein-repl
        "(do (require 'figwheel-sidecar.repl-api)
             (figwheel-sidecar.repl-api/start-figwheel!)
             (figwheel-sidecar.repl-api/cljs-repl))"))

  (use-package clojure-mode
    :ensure t)

  (use-package sicp
    :ensure t)

  (use-package geiser
    :ensure t)

  (use-package paredit
    :ensure t
    :config
    (enable-paredit-mode))

  (add-hook 'emacs-lisp-mode-hook       'enable-paredit-mode)
  (add-hook 'lisp-mode-hook             'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook 'enable-paredit-mode)
  (add-hook 'scheme-mode-hook           'enable-paredit-mode)

  (defvar my/lisp-mode-hooks '(emacs-lisp-mode-hook lisp-mode-hook lisp-interaction-mode-hook scheme-mode-hook clojure-mode-hook))

  (dolist (mode my/lisp-mode-hooks)
    (add-hook mode #'enable-paredit-mode)
    (add-hook mode #'evil-cleverparens-mode))

  (use-package clj-refactor
    :ensure t
    :config
    (add-hook 'clojure-mode-hook #'my/clojure-mode-hook))

  (defun my/clojure-mode-hook ()
    (clj-refactor-mode 1)
    (yas-minor-mode 1))

#+END_SRC

#+RESULTS:
: my/clojure-mode-hook

** Python
*** Virtualenv

pyvenv is nice because it lets me choose between virtualenvs made through mkvirtualenvwrapper and virtulenvs that are in other places on the filesystem.

We also set up eshell so that it shares its environment with emacs, thus using the virtualenv if it is set.

#+BEGIN_SRC emacs-lisp 

  (use-package pyvenv
    :ensure t
    :config
    (setq eshell-modify-global-environment t)
    (setq eshell-path-env (getenv "PATH")))

#+END_SRC

#+RESULTS:
*** anaconda-mode
Lots of goodies for Python development.

#+BEGIN_SRC emacs-lisp
 ;; (use-package anaconda-mode
 ;;   :ensure t
 ;;   :config
 ;;   (add-hook 'python-mode-hook 'anaconda-mode)
 ;;   (add-hook 'python-mode-hook 'anaconda-eldoc-mode))
#+END_SRC

#+RESULTS:
: t
*** Refactoring

#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :ensure t
    :config
    
    ;; Set pytest as the default test runner
    (elpy-set-test-runner 'elpy-test-pytest-runner)

    (elpy-enable))
#+END_SRC

#+RESULTS:
: t

** JSON
#+BEGIN_SRC emacs-lisp 

  (use-package json-mode
    :ensure t)

#+END_SRC
** Markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t)
#+END_SRC

#+RESULTS:

** Swift
#+BEGIN_SRC emacs-lisp 

(use-package swift-mode
  :ensure t)

#+END_SRC
** CoffeeScript
#+BEGIN_SRC emacs-lisp 

(use-package coffee-mode
  :ensure t)

#+END_SRC
** JavaScript
*** REPL
js-comint lets me run a repl inside emacs where I can evaluate JavaScript.

#+BEGIN_SRC emacs-lisp 

(use-package js-comint
  :ensure t)

#+END_SRC
** Haskell
#+BEGIN_SRC emacs-lisp 

(use-package haskell-mode
  :ensure t)

#+END_SRC
** Docker
*** Dockerfile mode
#+BEGIN_SRC emacs-lisp :tangle yes

  (use-package dockerfile-mode
    :ensure t)

#+END_SRC

#+RESULTS:
*** Docker mode
[[https://github.com/Silex/docker.el][Docker mode]] lets me run various docker commands.

#+BEGIN_SRC emacs-lisp 

  (use-package docker
    :ensure t
    :diminish docker-mode
    :config
    (docker-global-mode))

#+END_SRC

#+RESULTS:
: t

*** Environment variables
~docker-machine env default~ produces these environment variables, which must be set to use Docker.

#+BEGIN_SRC emacs-lisp
  (setenv "DOCKER_TLS_VERIFY" "1")
  (setenv "DOCKER_HOST" "tcp://192.168.99.100:2376")
  (setenv "DOCKER_CERT_PATH" "/Users/mark/.docker/machine/machines/default")
  (setenv "DOCKER_MACHINE_NAME" "default")
#+END_SRC

#+RESULTS:
: default
** Shell
Fish is my default shell in the terminal, but it doesn't work well in emacs, since many emacs integrations assume a sh-like shell. Let's use zsh instead.

#+BEGIN_SRC emacs-lisp
  (setq shell-file-name "/bin/zsh")
#+END_SRC
** YAML

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t)
#+END_SRC


* Org Mode
I use Org Mode to take notes for work and personal.

** My files
#+BEGIN_SRC emacs-lisp 

  (defun my/configure-org-directories ()
    (setq org-directory "~/org")
    (setq org-default-notes-file "~/org/refile.org")
    (setq org-agenda-files (quote ("~/org")))
    (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6)))))

#+END_SRC
** General configuration
*** Open links in new frames

Here's a function that lets me open org links in a new frame. The default behavior is opening a link in a new buffer in the same frame, which doesn't always fit with my workflow -- sometimes I have org open in a separate frame, with the main editing frame on a different monitor.

#+BEGIN_SRC emacs-lisp
  (require 'cl)

  (defun org-open-other-frame ()
    "Jump to bookmark in another frame. See `bookmark-jump' for more."
    (interactive)
    (let ((org-link-frame-setup (acons 'file 'find-file-other-frame org-link-frame-setup)))
      (org-open-at-point)))
#+END_SRC

#+RESULTS:
: org-open-other-frame

*** Log drawer
I can type timestamped notes for a given tree with ~C-c C-z~. By default, they are appending to the top of the note. Let's stash then in the ~LOGBOOK~ drawer instead.

#+BEGIN_SRC emacs-lisp

  (setq org-log-into-drawer t)

#+END_SRC

#+RESULTS:
: t
*** Variable pitch mode

#+BEGIN_SRC emacs-lisp 

  (defun my/org-variable-pitch ()
    "Use variable pitch for prose text in org."
    (interactive)
    (variable-pitch-mode t)
    (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-block nil :inherit 'fixed-pitch))

#+END_SRC

#+RESULTS:
: my/org-variable-pitch

*** Putting it together
#+BEGIN_SRC emacs-lisp 

  (defun my/configure-org ()
    (setq org-image-actual-width 300)
    (setq org-src-fontify-natively t)
    (setq org-log-done 'time)

    (setq org-startup-truncated 'nil)
    (setq org-catch-invisible-edits 'smart)
    
    ;; Do not dim blocked tasks
    (setq org-agenda-dim-blocked-tasks nil)

    ;; Start up in org-indent-mode
    (setq org-startup-indented t)
    ;; Diminish org-indent-mode in the mode-line
    (eval-after-load 'org-indent '(diminish 'org-indent-mode)))


  (defun my/org-mode ()
    (my/org-mode-keyboard-shortcuts)
   ;; (my/org-variable-pitch)
    )

  (defun my/org-agenda-mode ()
    (my/org-agenda-keyboard-shortcuts))

  (setq-default fill-column 85)
  (setq-default left-margin-width 1)

#+END_SRC

#+RESULTS:
: 1

** Keyboard shortcuts
*** Editing

#+BEGIN_SRC emacs-lisp 

  (defun my/org-mode-keyboard-shortcuts ()
    (evil-leader/set-key-for-mode 'org-mode
      "*" 'org-ctrl-c-star
      "a" 'org-agenda
      "ih" 'org-insert-heading-after-current-and-enter-insert
      "is" 'org-insert-subheading-after-current-and-enter-insert
      "it" 'org-insert-todo-after-current-and-enter-insert
      "n" 'org-narrow-to-subtree
      "N" 'widen
      "ml" 'org-do-demote
      "mL" 'org-demote-subtree
      "mh" 'org-do-promote
      "mH" 'org-promote-subtree
      "mk" 'org-metaup
      "mj" 'org-metadown
      "s" 'org-schedule
      "t" 'org-todo))

#+END_SRC

#+RESULTS:
: my/org-mode-keyboard-shortcuts

*** Agenda

#+BEGIN_SRC emacs-lisp 

(defun my/org-agenda-keyboard-shortcuts ()
  (define-key org-agenda-mode-map "j" 'evil-next-line)
  (define-key org-agenda-mode-map "k" 'evil-previous-line))

#+END_SRC
** Editing
*** Useful functions

#+BEGIN_SRC emacs-lisp 

(defun org-insert-subheading-after-current ()
  (interactive)
  (org-insert-heading-after-current)
  (org-demote))

(defun org-insert-subheading-after-current-and-enter-insert ()
  (interactive)
  (org-insert-subheading-after-current)
  (evil-append 0))

(defun org-insert-heading-after-current-and-enter-insert ()
  (interactive)
  (org-insert-heading-after-current)
  (evil-append 0))

(defun org-insert-todo-after-current-and-enter-insert ()
  (interactive)
  (org-insert-todo-heading-respect-content)
  (evil-append 0))

#+END_SRC

** Tasks

#+BEGIN_SRC emacs-lisp 

(defun my/configure-org-todos ()
  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))

  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "red" :weight bold)
                ("NEXT" :foreground "blue" :weight bold)
                ("DONE" :foreground "forest green" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold)
                ("MEETING" :foreground "forest green" :weight bold)
                ("PHONE" :foreground "forest green" :weight bold))))

  (setq org-use-fast-todo-selection t))

#+END_SRC

** Agenda

#+BEGIN_SRC emacs-lisp 

#+END_SRC
** Exporters
#+BEGIN_SRC emacs-lisp 

  (defun my/configure-org-exporters ()
    (use-package ox-gfm)

    (use-package org-habit)

    (use-package ox-odt
      :config
      (setq org-odt-preferred-output-format "rtf"))

    (use-package ox-jira
      :ensure t)

    (use-package ox-rst
      :ensure t))
#+END_SRC

** Rifle
helm-org-rifle lets me search through open org files really quickly.

#+BEGIN_SRC emacs-lisp 

(use-package helm-org-rifle
  :ensure t)

#+END_SRC
** JIRA
I often link to JIRA issues in my tasks. This function lets me add link JIRA issues by issue title rather than needing to paste in the full link.

#+BEGIN_SRC emacs-lisp

  (defvar default-jira-repository)
  (setq default-jira-repository "getclef.atlassian.net")

  (defun org-jira-insert-link (issue-name description)
    "Add links to JIRA issues by title."
    (interactive "sIssue: \nsDescription: ")
    (let ((desc (if (string= "" description) issue-name description))) 
      (org-insert-link nil (concat "https://" default-jira-repository "/browse/" issue-name) desc)))

#+END_SRC

#+RESULTS:
: org-jira-insert-link

** Capture

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("t" "todo" entry (file+headline "~/org/refile.org" "Tasks")
           "* TODO [#A] %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n%a\n")))
#+END_SRC

#+RESULTS:
| t | todo | entry | (file+headline ~/org/refile.org Tasks) | * TODO [#A] %? |

** Installation
#+BEGIN_SRC emacs-lisp 

(use-package org
  :ensure org-plus-contrib
  :config

  (my/configure-org-directories)
  (my/configure-org-exporters)
  (my/configure-org-todos)
  (my/configure-org)

  (add-hook 'org-mode-hook #'my/org-mode)
  (add-hook 'org-agenda-mode-hook #'my/org-agenda-mode))

#+END_SRC

#+RESULTS:
: t

* IRC
** Circe
#+BEGIN_SRC emacs-lisp 

(use-package circe
  :ensure t
  :config

  (setq circe-network-options
        `(("Freenode"
           :nick "landakram"
           :channels (:after-auth
                      "#emacs"
                      "#clojure"
                      "#clojure-beginners"
                      "#iphonedev"
                      "#swift-lang")
           :nickserv-password "***REMOVED***"
           :reduce-lurker-spam t)))
  (enable-circe-color-nicks))

#+END_SRC
* RSS Feeds
** elfeed
#+BEGIN_SRC emacs-lisp 

(use-package elfeed
  :ensure t
  :config

  (setq elfeed-feeds
        '("https://www.natashatherobot.com/feed/"
          "http://lambda-the-ultimate.org/rss.xml"
          "http://sachachua.com/blog/feed/"
          "http://airspeedvelocity.net/feed/")))

#+END_SRC
** URL queue timeout
This is long so that fetching feeds does not timeout.

#+BEGIN_SRC emacs-lisp 

(setq url-queue-timeout 30)

#+END_SRC
* Email
** mu4e

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "/usr/local/Cellar/mu/0.9.9.5/share/emacs/site-lisp/mu/mu4e")

  (use-package mu4e
    :config
    ;; default
    (setq mu4e-maildir (expand-file-name "~/Maildir"))

    ;; (setq mu4e-drafts-folder "/[Gmail].Drafts")
    ;; (setq mu4e-sent-folder   "/[Gmail].Sent Mail")
    ;; (setq mu4e-trash-folder  "/[Gmail].Trash")

    ;; don't save message to Sent Messages, GMail/IMAP will take care of this
    (setq mu4e-sent-messages-behavior 'delete)

    ;; setup some handy shortcuts
    ;; (setq mu4e-maildir-shortcuts
    ;;       '(("/INBOX"             . ?i)
    ;;         ("/[Gmail].Sent Mail" . ?s)
    ;;         ("/[Gmail].Trash"     . ?t)))

    ;; allow for updating mail using 'U' in the main view:
    (setq mu4e-get-mail-command "offlineimap")

    (setq
     user-mail-address "me@markhudnall.com"
     user-full-name  "Mark Hudnall"
     ;; message-signature
     ;;  (concat
     ;;    "Foo X. Bar\n"
     ;;    "http://www.example.com\n")
     )

    ;; sending mail -- replace USERNAME with your gmail username
    ;; also, make sure the gnutls command line utils are installed
    ;; package 'gnutls-bin' in Debian/Ubuntu, 'gnutls' in Archlinux.

    (use-package smtpmail
      :ensure t
      :config
      (setq message-send-mail-function 'smtpmail-send-it
            starttls-use-gnutls t
            smtpmail-starttls-credentials
            '(("smtp.gmail.com" 587 nil nil))
            smtpmail-auth-credentials
            (expand-file-name "~/.authinfo.gpg")
            smtpmail-default-smtp-server "smtp.gmail.com"
            smtpmail-smtp-server "smtp.gmail.com"
            smtpmail-smtp-service 587
            smtpmail-debug-info t))

    (use-package evil-mu4e
      :ensure t)

    (use-package org-mu4e
      :config)

    (setq mu4e-contexts
      `( ,(make-mu4e-context
            :name "Personal"
            :enter-func (lambda () (mu4e-message "Switch to the Personal context"))
            ;; leave-func not defined
            :match-func (lambda (msg)
                          (when msg 
                            (mu4e-message-contact-field-matches msg 
                              :to "me@markhudnall.com")))
            :vars '((user-mail-address        . "me@markhudnall.com"  )
                    (user-full-name           . "Mark Hudnall" )
                    (mu4e-drafts-folder       . "/Personal/[Gmail].Drafts")
                    (mu4e-sent-folder         . "/Personal/[Gmail].Sent Mail")
                    (mu4e-trash-folder        . "/Personal/[Gmail].Trash")
                    (mu4e-refile-folder       . "/Personal/[Gmail].All Mail")
                    (mu4e-maildir-shortcuts   . (("/Personal/INBOX" . ?i)
                                                  ("Personal/[Gmail].Sent Mail"  . ?s)
                                                  ("Personal/[Gmail].Trash" . ?t)))
                    (mu4e-compose-signature   . nil)))
         ,(make-mu4e-context
            :name "Work"
            :enter-func (lambda () (mu4e-message "Switch to the Work context"))
            ;; leave-fun not defined
            :match-func (lambda (msg)
                          (when msg 
                            (mu4e-message-contact-field-matches msg 
                              :to "mark@getclef.com")))
            :vars '((user-mail-address        . "mark@getclef.com" )
                    (user-full-name           . "Mark Hudnall" )
                    (mu4e-drafts-folder       . "")
                    (mu4e-drafts-folder       . "/Work/[Gmail].Drafts")
                    (mu4e-sent-folder         . "/Work/[Gmail].Sent Mail")
                    (mu4e-trash-folder        . "/Work/[Gmail].Trash")
                    (mu4e-refile-folder       . "/Work/[Gmail].All Mail")
                    (mu4e-maildir-shortcuts   . (("/Work/INBOX" . ?i)
                                                  ("Work/[Gmail].Sent Mail"  . ?s)
                                                  ("Work/[Gmail].Trash" . ?t)))
                    (mu4e-compose-signature .
                     (concat
                      "---\n"
                      "Mark Hudnall\n"
                      "CTO and Co-founder of Clef\n"
                      "mark@getclef.com"))))))

    ;; set `mu4e-context-policy` and `mu4e-compose-policy` to tweak when mu4e should
    ;; guess or ask the correct context, e.g.

    ;; start with the first (default) context; 
    ;; default is to ask-if-none (ask when there's no context yet, and none match)
    ;; (setq mu4e-context-policy 'pick-first)

    ;; compose with the current context is no context matches;
    ;; default is to ask 
    ;; '(setq mu4e-compose-context-policy nil)

    (setq mu4e-update-interval 300))
#+END_SRC

#+RESULTS:
: t


